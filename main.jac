# Codebase Genius - Main API Server
# Entry point for the Jac server that exposes walkers as API endpoints.

# Usage:
#     jac serve main.jac
#
# API Endpoints:
#     POST /walker/analyze_repository - Start full repository analysis
#     POST /walker/quick_analyze - Quick validation check
#     GET  /walker/check_status - Check analysis status
#     GET  /walker/get_documentation - Retrieve generated documentation

import os;
import json;
import from datetime { datetime }

# Import from local modules (subdirectories)
import from models.nodes { Repository, DocumentationNode, FileNode }
import from utils.git_helpers { GitHelper }
import from utils.file_helpers { FileSystemHelper, FilePrioritizer }
import from agents.supervisor { CodeGeniusSupervisor }
import from agents.repo_mapper { RepoMapper }
import from agents.code_analyzer { CodeAnalyzer }
import from agents.doc_genie { DocGenie }

# ==================== CONFIGURATION ====================

glob CONFIG: dict = {
    "output_dir": "./outputs",
    "max_size_mb": 500,
    "max_files": 100,
    "temp_dir": "./temp"
};

# ==================== MAIN ANALYSIS WALKER (API Endpoint) ====================

walker analyze_repository {
    has repo_url: str;
    has max_size_mb: int = CONFIG["max_size_mb"];
    has max_files: int = CONFIG["max_files"];
    has include_diagrams: bool = True;
    has cleanup_workspace: bool = True;
    
    can analyze with entry {
        print("\n" + "="*70);
        print("ðŸš€ API REQUEST: Analyze Repository");
        print("="*70);
        print("URL: " + self.repo_url);
        print("Max Size: " + str(self.max_size_mb) + "MB");
        print("Max Files: " + str(self.max_files));
        print("="*70 + "\n");

        # Validate input
        if not self.repo_url {
            report {
                "success": False,
                "error": "Repository URL is required",
                "timestamp": str(datetime.now())
            };
            disengage;
        }

        # Create repository node
        repo_name = GitHelper.extract_repo_name(self.repo_url);
        repo = here ++> Repository(
            name=repo_name,
            url=self.repo_url,
            local_path="",
            status="analyzing",
            created_at=str(datetime.now())
        );

        # Spawn REAL supervisor to run the pipeline
        supervisor = CodeGeniusSupervisor(
            repo_url=self.repo_url,
            output_dir=CONFIG["output_dir"],
            max_size_mb=self.max_size_mb,
            max_files=self.max_files,
            include_diagrams=self.include_diagrams,
            cleanup_workspace=self.cleanup_workspace
        ) spawn here;

        # Execute pipeline and wait for result
        result = supervisor.orchestrate;

        # Update repository status
        if result["success"] {
            repo.status = "completed";
            repo.total_files = result["files_analyzed"];
            repo.analyzed_files = result["files_analyzed"];

            # Documentation node created by DocGenie agent
            # Check if it exists
            docs = [repo -->(`?DocumentationNode)];
            if len(docs) == 0 {
                # Fallback: create basic doc node
                doc_node = repo ++> DocumentationNode(
                    doc_content="# Documentation for " + repo_name + "\n\nGenerated by Codebase Genius",
                    generated_at=str(datetime.now())
                );
            }

            report {
                "success": True,
                "message": "Repository analyzed successfully",
                "data": result,
                "repo_name": repo_name,
                "timestamp": str(datetime.now())
            };
        } else {
            repo.status = "failed";
            report {
                "success": False,
                "message": "Analysis failed",
                "error": result.get("error", "Unknown error"),
                "data": result,
                "timestamp": str(datetime.now())
            };
        }
    }
}

# ==================== QUICK ANALYSIS WALKER (API Endpoint) ====================

walker quick_analyze_api {
    has repo_url: str;
    
    can validate with entry {
        print("\nðŸ” API REQUEST: Quick Analyze - " + self.repo_url + "\n");
        
        if not self.repo_url {
            report {
                "success": False,
                "error": "Repository URL is required"
            };
            disengage;
        }
        
        # Validate GitHub URL using GitHelper
        is_valid = GitHelper.validate_github_url(self.repo_url);
        
        if is_valid {
            validation_result = {
                "valid": True,
                "message": "Valid GitHub repository URL",
                "repo_url": self.repo_url
            };
        } else {
            validation_result = {
                "valid": False,
                "message": "Invalid or unsupported repository URL",
                "repo_url": self.repo_url
            };
        }
        
        report {
            "success": True,
            "validation": validation_result,
            "timestamp": str(datetime.now())
        };
    }
}

# ==================== STATUS CHECKER WALKER (API Endpoint) ====================

walker check_status_api {
    has repo_name: str;
    
    can get_status with entry {
        print("\nðŸ“Š API REQUEST: Check Status - " + self.repo_name + "\n");
        
        if not self.repo_name {
            report {
                "success": False,
                "error": "Repository name is required"
            };
            disengage;
        }
        
        # Find repository nodes
        repos = [-->(`?Repository)](?name == self.repo_name);
        
        if len(repos) > 0 {
            repo = repos[0];
            status_result = {
                "repo_name": self.repo_name,
                "status": repo.status,
                "progress": repo.analyzed_files / repo.total_files if repo.total_files > 0 else 0.0,
                "total_files": repo.total_files,
                "analyzed_files": repo.analyzed_files
            };
        } else {
            status_result = {
                "repo_name": self.repo_name,
                "status": "not_found",
                "progress": 0.0
            };
        }
        
        report {
            "success": True,
            "status": status_result,
            "timestamp": str(datetime.now())
        };
    }
}

# ==================== GET DOCUMENTATION WALKER (API Endpoint) ====================

walker get_documentation {
    has repo_name: str;
    has format: str = "markdown";
    
    can retrieve_docs with entry {
        print("\nðŸ“„ API REQUEST: Get Documentation - " + self.repo_name + "\n");
        
        if not self.repo_name {
            report {
                "success": False,
                "error": "Repository name is required"
            };
            disengage;
        }
        
        # Find repository node
        repos = [-->(`?Repository)](?name == self.repo_name);
        
        if len(repos) == 0 {
            report {
                "success": False,
                "error": "Repository '" + self.repo_name + "' not found"
            };
            disengage;
        }
        
        repo = repos[0];
        
        # Find documentation node
        docs = [repo -->(`?DocumentationNode)];
        
        if len(docs) == 0 {
            report {
                "success": False,
                "error": "Documentation not generated yet"
            };
            disengage;
        }
        
        doc = docs[0];
        
        # Return documentation
        if self.format == "json" {
            report {
                "success": True,
                "repo_name": repo.name,
                "repo_url": repo.url,
                "documentation": {
                    "content": doc.doc_content,
                    "generated_at": doc.generated_at,
                    "version": doc.version,
                    "sections": doc.sections
                },
                "timestamp": str(datetime.now())
            };
        } else {
            # Return markdown content
            report {
                "success": True,
                "repo_name": repo.name,
                "content": doc.doc_content,
                "generated_at": doc.generated_at,
                "timestamp": str(datetime.now())
            };
        }
    }
}

# ==================== LIST REPOSITORIES WALKER (API Endpoint) ====================

walker list_repositories {
    can list_all with entry {
        print("\nðŸ“‹ API REQUEST: List Repositories\n");
        
        # Get all repository nodes
        repos = [-->(`?Repository)];
        
        if len(repos) == 0 {
            report {
                "success": True,
                "count": 0,
                "repositories": [],
                "message": "No repositories analyzed yet"
            };
            disengage;
        }
        
        # Build repository list
        repo_list = [];
        for repo in repos {
            # Check if documentation exists
            docs = [repo -->(`?DocumentationNode)];
            has_docs = len(docs) > 0;
            
            repo_info = {
                "name": repo.name,
                "url": repo.url,
                "status": repo.status,
                "total_files": repo.total_files,
                "analyzed_files": repo.analyzed_files,
                "created_at": repo.created_at,
                "has_documentation": has_docs
            };
            
            if has_docs {
                repo_info["doc_generated_at"] = docs[0].generated_at;
            }
            
            repo_list.append(repo_info);
        }
        
        report {
            "success": True,
            "count": len(repo_list),
            "repositories": repo_list,
            "timestamp": str(datetime.now())
        };
    }
}

# ==================== HEALTH CHECK WALKER (API Endpoint) ====================

walker health_check {
    can check_health with entry {
        # Check git installation using GitHelper
        git_installed = GitHelper.is_git_installed();
        
        # Check output directory
        output_dir_exists = os.path.exists(CONFIG["output_dir"]);
        
        # Get repository count
        repos = [-->(`?Repository)];
        
        health_status = {
            "status": "healthy",
            "git_installed": git_installed,
            "output_dir_exists": output_dir_exists,
            "output_dir": CONFIG["output_dir"],
            "repositories_analyzed": len(repos),
            "config": {
                "max_size_mb": CONFIG["max_size_mb"],
                "max_files": CONFIG["max_files"]
            },
            "timestamp": str(datetime.now())
        };
        
        if not git_installed or not output_dir_exists {
            health_status["status"] = "degraded";
        }

        report {
            "success": True,
            "health": health_status
        };
    }
}

# ==================== ENTRY POINT ====================

with entry {
    print("\n" + "="*70);
    print(" CODEBASE GENIUS - API SERVER STARTED");
    print("="*70);
    print("\n Available Endpoints:");
    print("  POST /walker/analyze_repository - Full repository analysis");
    print("  POST /walker/quick_analyze_api - Quick validation");
    print("  POST /walker/check_status_api - Check analysis status");
    print("  POST /walker/get_documentation - Get documentation");
    print("  POST /walker/list_repositories - List all repositories");
    print("  POST /walker/health_check - Health check");
    print("\n Example Usage:");
    print("  curl -X POST http://localhost:8000/walker/analyze_repository");
    print("    -H 'Content-Type: application/json'");
    print("    -d with repo_url in JSON format");
    print("\n" + "="*70 + "\n");

    # Ensure output directory exists
    os.makedirs(CONFIG["output_dir"], exist_ok=True);

    print(" Output directory ready: " + CONFIG["output_dir"]);
    print(" Configuration loaded");
    print("\n Server is ready to accept requests!\n");
}